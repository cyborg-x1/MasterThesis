\chapter{SignRecognition}
\graphicspath{{./Software/img/}}
 
\section{Depth Image Processing}


\subsection{Blur Filtering}
Bluring the depth image sounds like an easy task but 
if a simple boxed, gaussian or blur filter is used all etches are lost (see in figure \vref{figure:blurfail}).
At first it was tried to do all the filtering and reset all blured pixels $P_n$ which are to far away from their 
original depth value by the following formula.

\[
 \forall P_n(x,y)  |   \left(\left|{P_n(x,y)-P(x,y)}\right|>{\frac{P(x,y)^2}{480000}}\right)\implies P_n(x,y)=P(x,y)
\]

The following listing shows the code of this first filter, which uses a box-filter and and a median-blur filter from
OpenCV. In the next step the previous formula is used to move pixels, which are too far away, back to their original depth.
In the end another blur filter is applied to remove possible noise on the borders of the surfaces.

{
\tiny
\newpage
\begin{lstlisting}
cv::Mat filter_in = src.clone();
cv::Mat filter=filter_in.clone();
cv::boxFilter(filter, filter, 3, cv::Size(7, 3), cv::Point(-1, -1), 1, 0);
cv::medianBlur(filter, filter, 3);

//Update non zero pixels
for (int y = 0; y < src.rows; y++)
{
	for (int x = 0; x < src.cols; x++)
	{
		short realValue = filter_in.at<Vec1shrt>(y, x)[0];
		short filteredValue = filter.at<Vec1shrt>(y, x)[0];
		short maxDifference = pow((float)realValue, 2) / (480000); //Maximal difference from the real value
		if (realValue>0)
		{
			if(abs(realValue - filteredValue) > maxDifference)
			{
				dst.at<Vec1shrt>(y, x)[0] = realValue;
			}
			else
			{
				dst.at<Vec1shrt>(y, x)[0] = filteredValue;
			}
		}
	}
}
cv::medianBlur(dst, dst, 3);

\end{lstlisting}
}





% 			cv::Mat steps, neighbor_map, normals, xy,angles, angles_ok, filtered_bgr;
% 
% 
% 			///
% 			KinTo::convertKinectRawToSteps(imgPtrDepth->image,steps);  ///?
% 			KinTo::createRelationNeighbourhoodMap(steps,neighbor_map);
% 			KinTo::crossDepthBlur(imgPtrDepth->image,neighbor_map,imgPtrDepth->image,blur_depth);
% 			///
% 
% 			///
% 			KinTo::createXYMap(imgPtrDepth->image,info_msg,xy);
% 			KinTo::XYZrangeFilter(imgPtrDepth->image,xy,imgPtrDepth->image,x_min, x_max,  y_min, y_max, z_min, z_max);
% 			///
% 
% 			///
% 			KinTo::createNormalMap(imgPtrDepth->image,neighbor_map, xy,normals);
% 			KinTo::createAngleMap(normals,angles);
% 			///
% 
% 			///
% 			KinTo::crossAnglesBlur(angles,neighbor_map,angles,blur_angles);
% 			KinTo::anglesFilter(angles, angles_ok, x_angle_min, x_angle_max, y_angle_min, y_angle_max, z_angle_min, z_angle_max,true);
% 			///
% 
% 
% 			cv::blur(angles_ok,angles_ok,cv::Size(5,5),cv::Point(-1,-1),0);
% 			cv::threshold(angles_ok,angles_ok,1,255,0);



\pic{KinectOriginal.png}{Kinect RAW picture (Point Cloud)}{\label{figure:blurfail}}{0.6}{h}

\pic{BlurFilterFail.png}{Depth Image with Boxed Filter (Point Cloud)}{\label{figure:blurfail}}{0.6}{h}

\pic{neighborhoodmap.pdf}{Neighborhood-Map Creation}{\label{figure:crossblur}}{1}{h}

\pic{crossBlur.pdf}{Cross Blur Working Principle}{\label{figure:crossblur}}{1}{h}

\pic{normals.pdf}{Normals Creation}{\label{figure:normals}}{1}{h}



\subsection{Range Filter}



\section{RGB Image Processing}


\section{Robot Control}
\subsection{ROS Transform}
\subsection{Navigation}
